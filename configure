#!/usr/bin/env python3
MAKEFILE_NOTICE = """Copyright (C) 2025 -  PsychedelicPalimpsest  

Permission is hereby granted, free of charge, to any person obtaining a copy of 
this software and associated documentation files (the “Software”), to deal 
in the Software without restriction, including without limitation the rights to 
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies 
of the Software, and to permit persons to whom the Software is furnished to do 
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all 
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, 
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE 
SOFTWARE.

-----------------------------------------------------------------------------

This file is AUTOGENERATED! DO NOT EDIT.
"""

import re
import os

# Ensure the script runs in the proper directory
DIR = os.path.dirname(os.path.abspath(__file__))
os.chdir(DIR)





def makefile_escape(s):
    # Escape backslashes first
    s = s.replace('\\', '\\\\')
    # Escape dollar signs (Makefile variable reference)
    s = s.replace('$', '$$')
    # Escape hash (comment start)
    s = s.replace('#', '\\#')
    # Escape leading spaces/tabs (Makefile trims these)
    s = re.sub(r'^( +)', lambda m: '\\' * len(m.group(1)), s, flags=re.MULTILINE)
    s = re.sub(r'^(\t+)', lambda m: '\\' * len(m.group(1)), s, flags=re.MULTILINE)
    # Replace newlines with literal \n
    s = s.replace('\n', '\\n')
    # Quote if contains spaces or special chars
    if re.search(r'[ \t#\\$]', s):
        s = '{}'.format(s.replace('"', '\\"'))
    return s
def makefile_comment(s):
    return "# " + s.replace("\n", "\n# ") + "\n"


# Helper function, ensures a list based functions can handle strings properly
def str_sheild(s):
    return (s, ) if type(s) is str else s 

class GlobalVar:
    def __init__(self, name, values = None):
        self.name = name
        self.values = [] if values is None else str_sheild(values)
    def append(self, value):
        self.values.append(value)
    def generate(self, indent = 0):
        return "\t" * indent + self.name + "\t=\t" + makefile_escape(" ".join(self.values)) + "\n"

def dict_to_global_vars(dic):
    return {
        k: GlobalVar(k, [v])
        for k, v in dic.items()
    }

class Rule:
    def __init__(self, outputs, requires, lines = None):
        self.outputs = outputs
        self.requires = requires
        self.lines = [] if lines is None else lines
    def generate(self, indent = 0):
        s = "\t" * indent + " ".join(str_sheild(self.outputs)) + "\t:\t" + " ".join(str_sheild(self.requires))
        
        prefix = ("\n" + "\t" * (indent + 1))

        s += prefix + prefix.join(str_sheild(self.lines))
        return s + "\n"

from string import whitespace
def parse_wine_makefile(path, force = False):
    f = open(f"wine/dlls/{path}/Makefile.in" if not force else path, "r")
    lines = iter(f.readlines()) 
    f.close()

    database = {}

    try:
        while True:
            line = next(lines)
            # Only care about vars
            if not "=" in line:
                continue
            # No comments
            if line.lstrip().startswith("#"):
                continue
            # Indented lines are likely rules
            if line[0] in whitespace:
                continue


            k, *v = line.strip().split("=")

            # Any additional equals are in the variable itself
            v = "=".join(v).strip()
            
            while v.endswith("\\"):
                v =  v[:-1] + " " +next(lines).strip()

            database[k.strip()] = v.lstrip()

    except StopIteration:
        return database


def evaluate_makefile_item(item, db1, db2):
    limit = 0
    while '$' in item and limit < 1024:
        limit += 1
        value_itr = iter(item)
        true_value = ""
        try:
            while True:
                c = next(value_itr)
                if c == '$':
                    following = next(value_itr)
                    if following == "$":
                        true_value += c
                        continue
                    if following not in "({":
                        raise Exception("Unknown char following $ in makefile: " + following)
                    ending = {'(': ')', '{': '}'}[following]


                    c = next(value_itr)
                    name = ""
                    while c != ending:
                        name += c
                        c = next(value_itr)
                    name = name.strip()
                    true_value += db1.get(name) if name in db1 else db2.get(name, "")
                    continue
                true_value += c 
        except StopIteration:
            pass
        item = true_value
    return item 
def evaluate_makefile(raw_database, inherits = None):
    if inherits is None: inherits = {}
    
    for k, v in raw_database.items():
        raw_database[k] = evaluate_makefile_item(v, raw_database, inherits)
       



class WineBuildSystem:
    def __init__(self):
        if not os.path.exists("wine/Makefile"):
            os.system("cd wine && ./configure")
        self.database =  parse_wine_makefile("wine/Makefile", True)
        evaluate_makefile(self.database)

        self.makefile_cache = {}
    def _makefile(self, path, force = False):
        mf = parse_wine_makefile(path, force=force)
        evaluate_makefile(mf, inherits=self.database)

        return mf
    def get_server_makefile(self):
        if "server" not in self.makefile_cache:
            self.makefile_cache["server"] = self._makefile("wine/server/Makefile.in", force = True)
        return self.makefile_cache["server"]

    def get_dll_makefile(self, path):
        if path not in self.makefile_cache:
            self.makefile_cache[path] = self._makefile(path, force = False)
        return self.makefile_cache[path]


class Makefile:
    def __init__(self, force_pic = False, alt_vals = None):
        if alt_vals is None:
            alt_vals = {}
        self.fpic_add = "-fPIC" if force_pic else ""
        self.variables = {
            **dict_to_global_vars({
                "CC": "gcc -m32",
                "RM": "rm -f",
                "CFLAGS": "-Iwine/include -D__WINESRC__ -DWINE_UNIX_LIB" 
            }),
            **dict_to_global_vars(alt_vals)
        }
        self.rules = {}

        self.system = WineBuildSystem()

        self.object_files = []
        self.extra_rm = []
    def generate(self, indent = 0):
        s = makefile_comment(MAKEFILE_NOTICE) + "\n\n\n"

        s += "".join((var.generate(indent=indent) for _, var in self.variables.items())) + "\n\n"


        if "all" in self.rules:
            s += self.rules["all"].generate(indent=indent) + "\n"
            del self.rules["all"]

        s += "\n".join(rule.generate(indent=indent) for _, rule in self.rules.items())

        return s
    def wine_makefile(self):
        if "wine/Makefile" in self.rules:
            return
        self.rules["wine/Makefile"] = Rule("wine/Makefile", "", lines = [
            "cd wine && ./configure"
        ])


    def winebuild(self):
        if "wine/tools/winebuild/winebuild" in self.rules:
            return
        self.wine_makefile()

        self.variables["winebuild"] = GlobalVar("winebuild", ["wine/tools/winebuild/winebuild"])

        self.rules["$(winebuild)"] = Rule("$(winebuild)", "wine/Makefile", lines = 
            "make -C wine tools/winebuild/winebuild"
        )
    def _c_files(self, path, config, opts):
        files = list(os.path.join(path, f) for f in config["SOURCES"].split(" ") if f.endswith(".c"))
        objs = list((f[:-2] + ".o" for f in files))

        self.object_files += objs
        
        rules = f"{opts} "

        for i, f in enumerate(files):
            if f in self.rules:
                continue
            edidx = os.path.basename(f)[:-2] + "_EXTRADEFS"
            local_cflags = rules
            if edidx in config:
                local_cflags += f" {config[edidx]}"


            obj = objs[i]

            self.rules[obj] = Rule(obj, f, lines = 
                f"$(CC) -c {f} -o $@ $(CFLAGS) {self.fpic_add} {local_cflags}"
            )


        return objs 

    def server(self):
        if "server" in self.rules:
            return
        server_conf = self.system.get_server_makefile()
        print(server_conf)
        
        objs = self._c_files(
            "wine/server",
            server_conf,
            "")

        self.rules["server"] = Rule("server", " ".join(objs))

    def clean(self):
        if "clean" in self.rules:
            return 

        self.rules["clean"] = Rule("clean", "", lines = [
            "xargs $(RM) < objects.txt",
            "$(RM) " + " ".join(self.extra_rm)

        ])

    def dynamic(self):
        if "build/dynamic.so" in self.rules:
            return

        self.rules["build/kask.so"] = Rule("build/kask.so", " ".join(self.object_files), lines = 
            "$(CC) $(CFLAGS) -shared -o build/kask.so @objects.txt")
        self.rules["dynamic"] = Rule("dynamic", "build/kask.so")

        self.extra_rm.append("build/kask.so")
    def all(self):
        if "all" in self.rules:
            return

        deps = [d for d in ("static", "dynamic") if d in self.rules]

        self.rules["all"] = Rule("all", " ".join(deps))


def main():
    mf = Makefile(True)
    mf.server()


    mf.dynamic()
    mf.all()
    mf.clean()

    f = open("Makefile", "w")
    f.write(mf.generate())
    f.close()


    f = open("objects.txt", "w")
    f.write("\n".join(mf.object_files))
    f.close()


if __name__ == "__main__":
    main()

